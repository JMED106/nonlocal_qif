/*********************************************/
/* Simulation of the non-localized FR model. */
/*********************************************/

/*******************/
/* Version beta 0. */
/*******************/

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<time.h>
#include<string.h>
#include<gsl/gsl_rng.h>		/* GNU Scientific library */
#include<gsl/gsl_randist.h>
#include<omp.h>		        /* Parallel OMP library */



/* Global variables declaration */
int debug = 0,			/* Boolean: debugging activator */
  d_level = 0;			/* Debugging level */
char DATA_FILE[50] = "input_data.conf";
char mesg[1024];
char mesg2[1024];

/* Additional libraries (custom libraries) */
#include "common.h"		/* This must be first */
#include "utils.h"
#include "nrutil.h"
#include "nr.h"


/* === FUNCTION  main ====================
 * Description:  Program Body
 *   Variables:  It accepts external arguments
 * ======================================= */

int main(int argc, char **argv) {

#ifdef _OPENMP    		/* Compilation with OMP */
  int numthreads;
  numthreads = omp_get_max_threads();
  omp_set_num_threads(numthreads);
#endif  

  /* +++++++++++++++++ External Things ++++++++++++++++++++++ */

  time_t ti;   struct tm *tm;  ti = time(NULL); tm = localtime(&ti);
  if((argc >1) && (argv[1][1] == 'd')) {debug = 1; d_level = 1;} /* Initial debugging */

  srand(time(NULL));
  gsl_rng_env_setup();		/* Random generator initialization */
  gsl_rng_default_seed = rand()*RAND_MAX;
  sprintf(mesg,"Seed: %ld ",gsl_rng_default_seed);  DEBUG(mesg);
  
  /* Date variables */
  char day[100], hour[100];  strftime(day, 100, "%m-%d-%Y",tm);  sprintf(hour,"%d.%02d",tm->tm_hour,tm->tm_min);

  /* +++++++++++++++++ Simulation variables ++++++++++++++++ */
  int i,j,t, t_max;
  int def = 0;
  int time_correction = 0;
  int TIME;

  /* Parameters (all the parameters are stored in a structure) */
  t_data *d,*data;
  d = malloc(sizeof(t_data));
  data = malloc(sizeof(t_data));

  /* Results Variables */
  int Nscan;

  FILE *fileR, *fileV,*fileRV;
  fileR = fopen("rt.dat","w");
  fileV = fopen("vt.dat","w");
  fileRV = fopen("rvt.dat","w");
  /* Dynamic variables (system variables) */
  double *R,*V;
  R = dvector(1,d->l);
  V = dvector(1,d->l);
  double *J;
  J = dvector(1,d->l);

  /*********************************/
  /* Program arguments assignation */
  /*********************************/
  *data = Scan_Data(DATA_FILE,*d);
  d = data;

  while((argc--) != 1) {	/* Terminal arguments can be handled */
    *data = Arg(argv[argc], *d);
    d = data;
    if(argv[1][0] != '-') def = 0;
  }

  d->dx = 2.0*M_PI/d->l;
  d->scan = 0;
#ifdef _OPENMP			/* Work is divided between the cores */
  int chunksize = d->l/numthreads;
  if(chunksize > 5) chunksize = 5;
#endif

  /* Initial tunning: step size, and scanning issues */
  t_max = (int)((float)d->TT/d->dt);
  Nscan = 1;
  /**********************************/
  /* New simulations can start here */
  /**********************************/

    /* InitialState_FR(FR,*d,4); */
    for(i=1 ;i<=d->l ;i++ ) {
      R[i]=(d->J0+sqrt(d->J0*d->J0+4.*M_PI*M_PI*d->eta))/(2.*M_PI*M_PI)+0*1E-6;
      R[i]+=-1E-4*cos(i*d->dx);
      V[i] = 0.0;
    }
    /* Reset counters */
    t = 0;
    TIME = 0.0;
    /* Run */
    do {			/* Tiempo */
      if(t%(t_max/10) == 0) { /* Control point */
	sprintf(mesg,"%d%% ",(int)(t*100.0/t_max));
	DEBUG(mesg);
      }

#pragma omp parallel for private(j) schedule(dynamic,chunksize)
      for(i=1 ;i<=d->l ;i++ ) {	/* Espacio */
	/* We compute the coupling J */
	J[i] = 0;
	for(j=1 ;j<=d->l ;j++ ) 
	  J[i] +=(d->J0+2.*d->J1*cos((i-j)*d->dx))*R[j];
	J[i] /= d->l;
      }
#pragma omp parallel for schedule(dynamic,chunksize)
      for(i=1 ;i<=d->l ;i++ ) {
	/* We integrate the ODEs */
	R[i] += d->dt*(d->Deta/M_PI + 2.*R[i]*V[i]);
	V[i] += d->dt*(d->eta + pow(V[i],2) - pow(R[i]*M_PI,2) + J[i]);
      }
      /* Results are stored */
      for(i=1 ;i<d->l ;i++ ) {
	fprintf(fileR ,"%lf ",R[i]);
	fprintf(fileV ,"%lf ",V[i]);
      }
      fprintf(fileR ,"\n");
      fprintf(fileV ,"\n");
      
      t++;
      TIME = t*d->dt;
    } while(TIME < d->TT);	/* Paso temporal (se puede hacer de la misma manera que en el QIF */

    /* Final shape is stored */
    for(i=1 ;i<=d->l ;i++ ) 
      fprintf(fileRV ,"%lf\t%lf\t%lf\t%lf\n",-M_PI + i*d->dx,R[i],V[i],J[i]);
ESPERA    

    fclose(fileR); 
 ESPERA

    fclose(fileV);
ESPERA

    fclose(fileRV);
ESPERA

  printf("\Hola voy a terminar...");
 ESPERA
  /* system("rm -r ./temp"); */
  printf("\n");

  return 0;  
}


